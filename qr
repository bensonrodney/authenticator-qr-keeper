#!/usr/bin/env python3

"""
The purpose of this script is to reproduce Google Authenticator QR codes
from a list of accounts defined in a file '/home/$USER/.qrcodes`

A list of accounts is displayed and you select which code you want to view.

Dependencies:
Requires the  'qrencode' package to be installed. If you don't have it, run the
command below:
    sudo apt-get install qrencode
"""

import copy
import getpass
import hashlib
import io
from pathlib import Path
from qrcode import QRCode
import re
import shlex
from subprocess import Popen, PIPE
import sys
import urllib.parse
from Crypto.Cipher import AES

TYPE_TOTP = 'totp'
TYPE_HOTP = 'hotp'

# iterations when hashing the password
PBKDF2_ITERATIONS = 10000

src_file = Path("/home/{}/.qrcodes".format(getpass.getuser()))


def RunCommand(cmd, bytes_output=True):
    """ Runs a local shell command.

        if the bytes_output boolean is set to True, the return value will
        contain bytes() objects rather than str() objects. On python 2 this has
        no effect.

        functions which call RunCommand are generally considered responsible for
        converting to str in python 3.
    """
    p = Popen(shlex.split(cmd),
              stdin=PIPE,
              stdout=PIPE,
              stderr=PIPE)
    stdout, stderr = p.communicate()

    if bytes_output:
        return stdout, stderr, p.returncode
    else:
        return stdout.decode(), stderr.decode(), p.returncode


def read_and_decrypt_file(file, password):
    '''
    Returns a file-like stream object (in memory) which contains the decrypted
    file data.
    The file will have been encrypted in bash using the command below:

	echo "${password}" | openssl aes-256-cbc -pbkdf2 -iter 10000 -salt -in ${infile} -out ${outfile} -pass stdin

    '''
    passwordbytes = password.encode('utf-8')

    with open(file, 'rb') as f:
        openssloutputbytes = f.read()

    # The first 16 bytes of the file are: 'Salted__XXXXXXXX' where 'XXXXXXXX' is the actual
    # salt bytes
    salt = openssloutputbytes[8:16]

    derivedkey = hashlib.pbkdf2_hmac('sha256', passwordbytes, salt, PBKDF2_ITERATIONS, 48)

    key = derivedkey[0:32]
    iv = derivedkey[32:48]

    # the ciphertext is all the bytes after 'Salted__XXXXXXXX'
    ciphertext = openssloutputbytes[16:]

    decryptor = AES.new(key, AES.MODE_CBC, iv)
    plaintext = decryptor.decrypt(ciphertext)

    # the last byte of the plaintext is the number of padding bytes
    pad_bytes_count = plaintext[-1]
    plaintext = plaintext[:-pad_bytes_count]
    try:
        plaintext = plaintext.decode()
        return io.StringIO(plaintext)
    except UnicodeDecodeError:
        return None


class Code(object):
    def __init__(self, acct, issuer, secret, pwtype=TYPE_TOTP, moreopts=""):
        self._type = pwtype
        self._acct = acct.strip()
        self._issuer = issuer.strip()
        self._secret = secret.strip()
        self._moreopts = moreopts.strip()

    def _get_acct(self):
        return copy.copy(self._acct)
    acct = property(_get_acct)

    def __str__(self):
        rv = "otpauth://{}/{}?secret={}&issuer={}"\
                 .format(self._type,
                         urllib.parse.quote(self._acct),
                         self._secret,
                         self._issuer)
        if len(self._moreopts) > 0:
            rv += "&{}".format(self._moreopts)
        return rv

    def show_qr(self):
        code = QRCode()
        code.add_data(str(self))
        code.print_ascii()


def parse_file(src, password):
    codes = []
    try:
        data_stream = read_and_decrypt_file(src, password)
        if not data_stream:
            return []
        lines = [l.strip() for l in data_stream.readlines()]
        lines = [l for l in lines if (len(l) > 0) and (l[0] != "#")]
        for l in lines:
            data = [d.strip() for d in l.split("|")]
            acct = data[0]
            issuer = data[1]
            secret = data[2]
            kwargs = {}
            if len(data) > 3 and len(data[3]) > 0:
                kwargs['pwtype'] = data[3]
            if len(data) > 4 and len(data[4]) > 0:
                kwargs['moreopts'] = data[4]
            codes.append(Code(acct, issuer, secret, **kwargs))
        return codes
    except FileNotFoundError:
        return None


def select_and_print_code(codes):
    sel = None
    codes.sort(key=Code._get_acct)
    while sel is None:
        print("\n\nSelect a code to view:\n\n")
        for i, c in enumerate(codes):
            print("    {:>2}) {}".format(i+1, c.acct))
        try:
            try:
                selection = input("\n\nEnter selection: ")
            except KeyboardInterrupt:
                return 1

            sel = int(selection)
            if sel < 1 or sel > len(codes):
                print("Selection invalid!\n\n")
                sel = None
        except ValueError:
            print("Selection invalid!")
            sel = None
        except KeyboardInterrupt:
            print("\nAborted!\n\n")
            return 1
    print(codes[sel-1].acct)
    codes[sel-1].show_qr()
    return 0


def main():
    if not src_file.is_file():
        print('ERROR: source file not found. Exiting.')
        return 1

    try:
        password = getpass.getpass()
    except KeyboardInterrupt:
        print()
        return 0

    codes = parse_file(str(src_file), password)
    if codes is None:
        print('ERROR! Couldn\'t parse source file.')
        return 1

    if len(codes) < 1:
        print('ERROR: No codes found in source file or the password is incorrect.')
        return 1

    choice_regex = re.compile(r'^([yY]|[yY][eE][sS]|)$')
    while True:
        try:
            if select_and_print_code(codes) != 0:
                print()
                break
            choice = input("Display another code? [Yn]: ")
            if not choice_regex.search(choice):
                break
        except KeyboardInterrupt:
            print()
            break


if __name__ == '__main__':
    sys.exit(main())

