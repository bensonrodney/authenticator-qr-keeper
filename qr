#!/usr/bin/env python3

"""
The purpose of this script is to reproduce Google Authenticator QR codes
from a list of accounts defined in a file '/home/$USER/.qrcodes`

A list of accounts is displayed and you select which code you want to view.

Dependencies:
Requires the  'qrencode' package to be installed. If you don't have it, run the
command below:
    sudo apt-get install qrencode
"""

import copy
import getpass
import hashlib
import io
from pathlib import Path
from qrcode import QRCode
import re
import shlex
from subprocess import Popen, PIPE
import sys
from urllib.parse import (
    parse_qs,
    quote,
    unquote,
    urlparse,
)
from Crypto.Cipher import AES

TYPE_TOTP = 'totp'
TYPE_HOTP = 'hotp'

# iterations when hashing the password
PBKDF2_ITERATIONS = 10000

src_file = Path("/home/{}/.qrcodes".format(getpass.getuser()))
leading_slashes = re.compile('^[/]{1,}')


def read_and_decrypt_file(file, password):
    '''
    Returns a file-like stream object (in memory) which contains the decrypted
    file data.
    The file will have been encrypted in bash using the command below:

	echo "${password}" | openssl aes-256-cbc -pbkdf2 -iter 10000 -salt -in ${infile} -out ${outfile} -pass stdin

    '''
    passwordbytes = password.encode('utf-8')

    with open(file, 'rb') as f:
        openssloutputbytes = f.read()

    # The first 16 bytes of the file are: 'Salted__XXXXXXXX' where 'XXXXXXXX' is the actual
    # salt bytes
    salt = openssloutputbytes[8:16]

    derivedkey = hashlib.pbkdf2_hmac('sha256', passwordbytes, salt, PBKDF2_ITERATIONS, 48)

    key = derivedkey[0:32]
    iv = derivedkey[32:48]

    # the ciphertext is all the bytes after 'Salted__XXXXXXXX'
    ciphertext = openssloutputbytes[16:]

    decryptor = AES.new(key, AES.MODE_CBC, iv)
    plaintext = decryptor.decrypt(ciphertext)

    # the last byte of the plaintext is the number of padding bytes
    pad_bytes_count = plaintext[-1]
    plaintext = plaintext[:-pad_bytes_count]
    try:
        plaintext = plaintext.decode()
        return io.StringIO(plaintext)
    except UnicodeDecodeError:
        return None


class Code(object):
    def __init__(self, url):
        self._raw = url.strip()
        self._url = urlparse(self._raw)
        self._name = None

    def _get_name(self):
        if not self._name:
            self._name = leading_slashes.sub("", unquote(self._url.path))
        return copy.copy(self._name)
    name = property(_get_name)

    def __str__(self):
        return copy.copy(self._raw)

    def show_qr(self):
        code = QRCode()
        code.add_data(str(self))
        code.print_ascii()


def parse_file(src, password):
    '''
    Handy notes:
    With a full URL, you can do the following:
        url = urllib.parse.urlparse("otpauth://totp/Code%20Name?secret=123456789&issuer=Some%20Company")
        print(urllib.parse.unquote(url.path)[1:])
        print(urllib.parse.parse_qs(url.query))

    Produces:
        Code Name
        {'secret': ['123456789'], 'issuer': ['Some Company']}
    '''
    codes = []
    try:
        data_stream = read_and_decrypt_file(src, password)
        if not data_stream:
            return []
        lines = [l.strip() for l in data_stream.readlines()]
        codes = [Code(l) for l in lines if (len(l) > 0) and (l[0] != "#")]
        return codes
    except FileNotFoundError:
        return None


def select_and_print_code(codes):
    sel = None
    codes.sort(key=Code._get_name)
    while sel is None:
        print("\n\nSelect a code to view:\n\n")
        for i, c in enumerate(codes):
            print("    {:>2}) {}".format(i+1, c.name))
        try:
            try:
                selection = input("\n\nEnter selection: ")
            except KeyboardInterrupt:
                return 1

            sel = int(selection)
            if sel < 1 or sel > len(codes):
                print("Selection invalid!\n\n")
                sel = None
        except ValueError:
            print("Selection invalid!")
            sel = None
        except KeyboardInterrupt:
            print("\nAborted!\n\n")
            return 1
    print(codes[sel-1].name)
    codes[sel-1].show_qr()
    return 0


def main():
    if not src_file.is_file():
        print('ERROR: source file not found. Exiting.')
        return 1

    try:
        password = getpass.getpass()
    except KeyboardInterrupt:
        print()
        return 0

    codes = parse_file(str(src_file), password)
    if codes is None:
        print('ERROR! Couldn\'t parse source file.')
        return 1

    if len(codes) < 1:
        print('ERROR: No codes found in source file or the password is incorrect.')
        return 1

    choice_regex = re.compile(r'^([yY]|[yY][eE][sS]|)$')
    while True:
        try:
            if select_and_print_code(codes) != 0:
                print()
                break
            choice = input("Display another code? [Yn]: ")
            if not choice_regex.search(choice):
                break
        except KeyboardInterrupt:
            print()
            break


if __name__ == '__main__':
    sys.exit(main())

